# Coding Standards

За основу взяты стандарты Symfony, включающие в себя [PSR-0](http://www.php-fig.org/psr/psr-0/), 
[PSR-1](http://www.php-fig.org/psr/psr-1/) и [PSR-2](http://www.php-fig.org/psr/psr-2/)

## [PSR-0](http://www.php-fig.org/psr/psr-0/)

[PSR-0](http://www.php-fig.org/psr/psr-0/) содержит обязательные требования, которые необходимо соблюдать для поддержания функциональной совместимости автозагрузчика.

* Полностью сформированное пространство имен и класс должны иметь следующую структуру `\<Vendor Name>\(<Namespace>\)*<Class Name>`
* Каждое пространство имен должно иметь пространство имен верхнего уровня (`Vendor Name`, в нашем случае `Rutorika`).
* Каждое пространство имен может содержать столько вложенных пространств имен, сколько ему необходимо.
* Каждый разделитель пространств имен преобразуется в `DIRECTORY_SEPARATOR` при загрузке из файловой системы.
* Каждый символ `_` в *имени класса* преобразуется в `DIRECTORY_SEPARATOR`. Символ `_` не имеет особого значения в *пространстве имен*.
* Полностью сформированное пространство имен и класс дополняются `.php` при загрузке из файловой системы.
* Буквы в именах поставщиков (vendors), пространствах имен и именах классов могут в любой комбинации строчных и прописных букв.

### Примеры

* `\Doctrine\Common\IsolatedClassLoader` => `/path/to/project/lib/vendor/Doctrine/Common/IsolatedClassLoader.php`
* `\Symfony\Core\Request` => `/path/to/project/lib/vendor/Symfony/Core/Request.php`
* `\Zend\Acl` => `/path/to/project/lib/vendor/Zend/Acl.php`
* `\Zend\Mail\Message` => `/path/to/project/lib/vendor/Zend/Mail/Message.php`

### Подчеркивания в Пространствах имен и Именах классов

`\namespace\package\Class_Name` => `/path/to/project/lib/vendor/namespace/package/Class/Name.php`
`\namespace\package_name\Class_Name` => `/path/to/project/lib/vendor/namespace/package_name/Class/Name.php`

## [PSR-1](http://www.php-fig.org/psr/psr-1/) Основной стандарт написания кода

Этот раздел стандартов включает в себя стандарт кода, необходимый для обеспечения высокого уровня технической взаимодействия между общим PHP кодом.

Ключевые слова "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" в этом документе должны быть истолкованы как описано в [RFC 2119](http://www.ietf.org/rfc/rfc2119.txt).

> "ДОЛЖЕН"/"НЕОБХОДИМО" (MUST), а также термины ТРЕБУЕТСЯ (REQUIRED) и НУЖНО (SHALL) используется для требований, которые являются абсолютно необходимыми в данной спецификации.

> "НЕДОПУТИМО" (MUST NOT) и "НЕ ПОЗВОЛЯЕТСЯ" (SHALL NOT) означают абсолютный запрет в рамках спецификации.

> "СЛЕДУЕТ" (SHOULD) и "РЕКОМЕНДУЕТСЯ" (RECOMMENDED) используется для обозначения требований, от выполнения которых можно отказаться при наличии разумных причин. Однако при таком отказе следует помнить о возможных проблемах в результате отказа и принимать взвешенное решение.

> "НЕ СЛЕДУЕТ" (SHOULD NOT) и "НЕ РЕКОМЕНДУЕТСЯ" (NOT RECOMMENDED) используются применительно к особенностям или функциям, которые допустимы и могут быть полезными, но могут вызывать проблемы. При реализации таких опций следует учитывать возможность возникновения проблем и принимать взвешенное решение.

> "ВОЗМОЖНО" (MAY) и "НЕОБЯЗАТЕЛЬНЫЙ" (OPTIONAL) обозначают элементы, реализация которых является необязательной. Одни разработчики могут включать такие опции в свою продукцию для расширения возможностей, а другие -опускать в целях упрощения. Реализация, не включающая ту или иную опцию, должна быть готова к работе с реализациями, которые используют эту опцию (возможно совместная работа будет обеспечиваться за счет некоторого ущерба функциональности). Включающие опцию реализации должны быть готовы (естественно, без использования такой опции) к взаимодействию с реализациями, которые такую опцию не поддерживают.

### Содержание

* Файлы ДОЛЖНЫ использовать только `<?php` и `<?=` теги.
* Файлы ДОЛЖНЫ использовать только UTF-8 без BOM для PHP кода.
* Файлам СЛЕДУЕТ либо объявлять знаки (классы, функции, константы, и т.д.) или оказывать побочный эффект (например, генерировать вывод, изменять .ini настройки, и т.д.) но НЕ СЛЕДУЕТ делать и то и другое.
* Пространства имен и классы ДОЛЖНЫ следовать [PSR-0](http://www.php-fig.org/psr/psr-0/).
* Имена классов ДОЛЖНЫ быть объявлены используя `StudlyCaps`.
* Константы класса ДОЛЖНЫ быть объявлены в верхнем регистре с подчеркиванием в качестве разделителей.
* Имена методов ДОЛЖНЫ быть объявлены используя `camelCase`.

### Файлы

#### PHP Теги

PHP код ДОЛЖЕН использовать длинные `<?php` `?>` теги или короткие-выводящие `<?=` `?>` теги; другие варианты тегов НЕ ДОЛЖНЫ использоваться.

#### Кодировка символов

PHP код ДОЛЖЕН использовать только UTF-8 без BOM.

#### Побочные эффекты

Файлу СЛЕДУЕТ объявлять знаки (классы, функции, константы, и т.д.), и не оказывать побочный эффект, или ему СЛЕДУЕТ выполнять логику 
с побочным эффектом, но НЕ СЛЕДУЕТ делать и то и другое.

Фраза "побочны эффекты" означает выполнение логики непосредственно не связанной с объявлением классов, функций, 
констант и т.д., просто от включения файла.

"Побочные эффекты" включают, но не ограничены: генерацией вывода, явным использованием `require` или `include`, подключением к внешним сервисам, 
изменениям настроек `ini`, выбрасыванием ошибок или исключений, изменением глобальных или статичных переменных, чтением или записью в файл, и так далее.

Ниже приведен пример файла с одновременно объявляющий знаки и оказывающий побочные эффекты; т.е., пример того, что следует избегать:

```php
// побочное действие: изменение настроек ini
ini_set('error_reporting', E_ALL);

// побочное действие: подключение файла
include "file.php";

// побочное действие: генерация вывода
echo "<html>\n";

// объявление
function foo()
{
    // тело функции
}
```

### Названия пространств имен и классов

Пространства имен и классы должны следовать стандарту [PSR-0](http://www.php-fig.org/psr/psr-0/).

Это значит, что каждый класс должен быть в отдельном файле, и внутри пространства имен хотя бы на один уровень, с верхнем уровнем - уровенем поставщика (vendor).

Имена кассов ДОЛЖНЫ быть названы используя формат `StudlyCaps` (каждое слово с большой буквы).

Код написанный на PHP 5.3 и старше ДОЛЖЕН использовать формальные пространства имен.

Например:

```php
namespace Vendor\Model;

class Foo
{
}
```

### Константы, свойства и методы классов


Термин класс включает всё: классы, интерфейсы и traits (примеси).

#### Константы

Константы классов ДОЛЖНЫ быть названы используя только большие буквы и нижнее подчеркивание для разделения слов. Пример:

```php
namespace Vendor\Model;

class Foo
{
    const VERSION = '1.0';
    const DATE_APPROVED = '2012-06-01';
}
```

#### Свойства

Стандарт намеренно избегает любых рекомендаций в отношении использования `$StudlyCaps`, `$camelCase` или `$under_score` в именах свойств.

Любое соглашение об именовани НУЖНО применять постоянно в рамках какого-то разумного объема. Таким объемом может быть уровень поставщика, пакета, класса или метода.

#### Методы

Методы ДОЛЖНЫ быть названы используя `camelCase()`.


## [PSR-2](http://www.php-fig.org/psr/psr-2/) Оформление кода

Это руководство продолжает и расширяет [PSR-1](http://www.php-fig.org/psr/psr-1/), основной стандарт написания кода.

Целью данного руководства является снижение неудобств в восприятии кода разных авторов при беглом осмотре. 
Это достигается перечислением общего наборов правил оформления и ожиданий от оформления кода.
Польза этого руководства не в самих правилах, а в обмене этими правилами.

### Содержание

* Код ДОЛЖЕН следовать [PSR-1](http://www.php-fig.org/psr/psr-1/).
* Код ДОЛЖЕН использовать 4 пробела для отступов, а не табуляцию.
* НЕ ДОЛЖНО быть жесткого ограничения на длину строки; мягкое ограничение ДОЛЖНО быть 120 знаков; строкам СЛЕДУЕТ быть 80 символов или менее.
* ДОЛЖНА быть одна пустая строка после объявления `namespace`, и ДОЛЖНА быть одна пустая строка после блока с объявлениями `use`.
* Открывающие фигурные скобки для классов ДОЛЖНЫ быть на новой строке, и закрывающие фигурные скобки ДОЛЖНЫ быть на новой строке после тела класса.
* Открывающие фигурные скобки для методов ДОЛЖНЫ быть на новой строке, и закрывающие фигурные скобки ДОЛЖНЫ быть на новой строке после тела метода.
* Область видимости ДОЛЖНА быть описана у всех свойств и методов; `abstract` и `final` ДОЛЖНЫ быть описаны перед областью видимости; `static` ДОЛЖНО быть описано после области видимости.
* Ключевые слова управляющих конструкций ДОЛЖНЫ иметь один пробел после себя; вызовы методов и функции НЕ ДОЛЖНЫ.
* Открывающие фигурные скобки для управляющих конструкций ДОЛЖНЫ быть на той же строке, а закрывающие фигурные скобки ДОЛЖНЫ быть на новой строке после тела конструкции.
* Открывающие круглые скобки для управляющих конструкций НЕ ДОЛЖНЫ иметь пробел после себя, а закрывающие круглые скобки для управляющих конструкций НЕ ДОЛЖНЫ иметь пробел перед собой.

#### Пример

Этот пример как краткий обзор включает в себя некоторые из ниже указанных правил:

```php
namespace Vendor\Package;

use FooInterface;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class Foo extends Bar implements FooInterface
{
    public function sampleFunction($a, $b = null)
    {
        if ($a === $b) {
            bar();
        } elseif ($a > $b) {
            $foo->bar($arg1);
        } else {
            BazClass::bar($arg2, $arg3);
        }
    }

    final public static function bar()
    {
        // тело метода
    }
}
```

### Общее

Код ДОЛЖЕН следовать всем правилам изложенным в [PSR-1](http://www.php-fig.org/psr/psr-1/).

Все PHP файлы ДОЛЖНЫ использовать переводы строк Unix LF (linefeed).

Все PHP файлы ДОЛЖНЫ оканчиваться одной пустой строкой.

Закрывающий `?>` тег ДОЛЖЕН быть исключен из файлов содержащих только PHP.

### Строки

НЕ ДОЛЖНО быть жесткого ограничения на длину строки.

Мягкое ограничение на длину строки ДОЛЖНО быть 120 знаков; автоматические проверки стиля ДОЛЖНЫ предупредить но НЕ ДОЛЖНЫ выдавать ошибку на мягкие ограничения.

Строкам НЕ СЛЕДУЕТ быть длиннее 80 знаков; более длинные строки СЛЕДУЕТ разбивать на несколько последующих строк не более чем 80 знаков в каждой.

НЕ ДОЛЖНО быть замыкающий пробелов в конце строки на не пустых строках.

Пустые строки МОГУТ быть добавлены для улучшения читабельности и для выделения связанных блоков кода.

НЕ ДОЛЖНО быть более одного выражения в строке.

### Отступы

Код ДОЛЖЕН использовать отступ в 4 пробела, и НЕ ДОЛЖЕН использовать табуляцию для отступов.

> Обратите особое внимание: Использование только пробелов, и не смешивание пробелов и табуляции, помогает избежать проблем с диффами, патчами, 
историей, и аннотациями. Использование пробелов также позволяет легко вставить тонко-настроенный суб-отступ для межстрочного выравнивания.

### Ключевые слова и True/False/Null

Все [Ключевые слова PHP](http://php.net/manual/en/reserved.keywords.php) ДОЛЖНЫ быть в нижнем регистре.

PHP константы `true`, `false`, и `null` ДОЛЖНЫ быть в нижнем регистре.

### Объявление Пространства имен и Use

Если они присутствуют, то ДОЛЖНА быть одна пустая строка после объявления namespace.

Если они присутствуют, все объявления use ДОЛЖНЫ идти после объявления namespace.

ДОЛЖНО быть ключевое слово use на каждое объявление.

ДОЛЖНА быть одна пустая строка после блока `use`.

Например:

```php
namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

// ... код ...
```

### Классы, свойства, и методы

Термин "класс" относится ко всем классам, интерфейсам и трейтам.

Ключевые слова `extends` и `implements` ДОЛЖНЫ быть объявлены на той же строке, что и имя класса.

Открывающая фигурная скобка для класса ДОЛЖНА идти на своей собственной строке; закрывающая фигурная скобка для класса ДОЛЖНА 
идти на следующей строке после тела класса.

```php
namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class ClassName extends ParentClass implements \ArrayAccess, \Countable
{
    // константы, свойства, методы
}
```

Список implements МОЖЕТ быть разделен на несколько строк, где каждая последующая строка с одним отступом. При этом первый элемент 
в списке ДОЛЖЕН быть на следующей строке, и ДОЛЖЕН быть только один интерфейс на строку.

```php
namespace Vendor\Package;

use FooClass;
use BarClass as Bar;
use OtherVendor\OtherPackage\BazClass;

class ClassName extends ParentClass implements
    \ArrayAccess,
    \Countable,
    \Serializable
{
    // константы, свойства, методы
}
```

### Свойства

Область видимости ДОЛЖНА быть объявлена у всех свойств.

Ключевое слово `var` НЕ ДОЛЖНО быть использовано для объявления свойства.

НЕ ДОЛЖНО быть более одного свойства объявленного в выражении (строке?).

Имена свойств НЕ СЛЕДУЕТ делать с подчеркиванием в качестве приставки для обозначения области видимости `protected` или `private`.

Объявление свойства выглядит следующим образом.

```php
namespace Vendor\Package;

class ClassName
{
    public $foo = null;
}
```

### Методы

Область видимости ДОЛЖНА быть объявлена на все методы.

Имена методов НЕ СЛЕДУЕТ делать с подчеркиванием в качестве приставки для обозначения области видимости `protected` или `private`.

Имена методов НЕ ДОЛЖНЫ быть объявлены с пробелом после имени метода. Открывающая фигурная скобка ДОЛЖНА идти на своей собственной строке, 
а закрывающая фигурная скобка ДОЛЖНА быть на следующей строке после тела метода. НЕ ДОЛЖНО быть пробела после открытия круглой скобки, 
и НЕ ДОЛЖНО быть пробела перед закрывающей круглой скобкой.

Объявление метода выглядит следующим образом. Обратите внимание на размещение круглых скобок, запятых, пробелов и фигурных скобок:

```php
namespace Vendor\Package;

class ClassName
{
    public function fooBarBaz($arg1, &$arg2, $arg3 = [])
    {
        // тело метода
    }
}
```

### Аргументы метода

В списке аргументов, НЕ ДОЛЖНО быть пробела перед каждой запятой, и ДОЛЖЕН быть один пробел после каждой запятой.

Аргументы Метода со значениями по умолчанию должны идти в конце списка аргументов.

```php
namespace Vendor\Package;

class ClassName
{
    public function foo($arg1, &$arg2, $arg3 = [])
    {
        // тело метода
    }
}
```

Список аргументов МОЖЕТ быть разделен на несколько строк, где каждая последующая строка с одним отступом. При этом первый элемент в списке 
ДОЛЖЕН быть на следующей строке, и ДОЛЖЕН быть только один аргумент на строку.

Когда список аргументов разделен на несколько строк, закрывающая круглая скобка и открывающая фигурная скобка 
ДОЛЖНЫ быть установлены вместе на отдельную строку с одним пробелом между ними.

```php
namespace Vendor\Package;

class ClassName
{
    public function aVeryLongMethodName(
        ClassTypeHint $arg1,
        &$arg2,
        array $arg3 = []
    ) {
        // тело метода
    }
}
```

### `abstract`, `final`, и `static`

Если они присутствуют, то `abstract` и `final` ДОЛЖНЫ предшествовать перед объявлением области видимости.

Если присутствует объявление `static`, то оно ДОЛЖНО идти после объявления области видимости.

```php
namespace Vendor\Package;

abstract class ClassName
{
    protected static $foo;

    abstract protected function zim();

    final public static function bar()
    {
        // тело метода
    }
}
```

### Вызовы методов и функций

При выполнении вызова метода или функции, НЕ ДОЛЖНО быть пробела между именем метода или функции и открывающей круглой скобкой, 
НЕ ДОЛЖНО быть пробела после открытия круглой скобки, а также НЕ ДОЛЖНО быть пробела перед закрывающей круглой скобкой. В списке 
аргументов, НЕ ДОЛЖНО быть пробела перед каждой запятой, и ДОЛЖЕН быть один пробел после каждой запятой.

```php
bar();
$foo->bar($arg1);
Foo::bar($arg2, $arg3);
```

Списки аргументов МОГУТ быть разделены на несколько строк, где каждая последующая строка с одним отступом. При этом первый элемент в списке 
ДОЛЖЕН быть на следующей строке, и ДОЛЖЕН быть только один аргумент на строку.

```php
$foo->bar(
    $longArgument,
    $longerArgument,
    $muchLongerArgument
);
```

### Управляющие конструкции

Общие правила стиля для управляющих конструкций следующие:

* ДОЛЖЕН быть один пробел после ключевого слова управляющей конструкции
* НЕ ДОЛЖНО быть пробела после открывающих круглых скобок
* НЕ ДОЛЖНО быть пробела перед закрывающими круглыми скобками
* ДОЛЖЕН быть один пробел между закрывающей круглой скобкой и открывающей фигурной скобкой
* Тело конструкции должно быть с одним отступом
* Закрывающая фигурная скобка ДОЛЖНА быть на следующей строке после тела управляющей конструкции

Тело каждой конструкции ДОЛЖНО быть заключено в фигурные скобки. Это стандартизирует вид конструкций, 
и уменьшает вероятность внесения ошибок при добавлении новых строк к телу управляющей конструкции.


#### `if`, `elseif`, `else`

Оператор `if` выглядит следующим образом. Обратите внимание на размещение круглых скобок, пробелов и фигурных скобок; 
и что `else` и `elseif` находятся на одной линии, как и закрывающая фигурная скобка тела оператора.

```php
if ($expr1) {
    // тело оператора if
} elseif ($expr2) {
    // тело оператора elseif
} else {
    // тело оператора else;
}
```

Ключевое слово `elseif` СЛЕДУЕТ использовать вместо `else if` так что все управляющие ключевые слова выглядят как единые слова.

#### `switch`, `case`

Конструкция `switch` выглядит следующим образом.
Оператор `case` ДОЛЖЕН быть с одним отступом от `switch`, а ключевое слово `break` (или другое завершающее ключевое слово) ДОЛЖНО быть 
с таким же отступом как тело оператора `case`. ДОЛЖЕН быть комментарий, такой как `// no break` когда есть преднамеренное падение 
в не-пустое тело оператора `case`.

```php
switch ($expr) {
    case 0:
        echo 'First case, with a break';
        break;
    case 1:
        echo 'Second case, which falls through';
        // no break
    case 2:
    case 3:
    case 4:
        echo 'Third case, return instead of break';
        return;
    default:
        echo 'Default case';
        break;
}
```

#### `while`, `do while`

Оператор `while` выглядит следующим образом.

```php
while ($expr) {
    // structure body
}
```

Кроме того, оператор `do while` выглядит следующим образом.

```php
do {
    // structure body;
} while ($expr);
```

#### `for`

```php
for ($i = 0; $i < 10; $i++) {
    // тело оператора for
}
```

#### `foreach`

```php
foreach ($iterable as $key => $value) {
    // тело оператора foreach
}
```

#### `try`, `catch`

```php
try {
    // тело оператора try
} catch (FirstExceptionType $e) {
    // тело оператора catch
} catch (OtherExceptionType $e) {
    // тело оператора catch
}
```

### Замыкания

Замыкания ДОЛЖНЫ быть объявлены с пробелом после ключевого слова function, и пробелом перед и после ключевого слова use.

Открывающая фигурная скобка ДОЛЖНА идти на той же строке, а закрывающая фигурная скобка ДОЛЖНА идти на следующей строке после тела функции.

НЕ ДОЛЖНО быть пробела после открывающей круглой скобки списка аргументов или списка переменных, и НЕ ДОЛЖНО быть пробела перед закрывающей 
круглой скобкой списка аргументов или списка переменных.

В списке аргументов и списке переменных НЕ ДОЛЖНО быть пробела перед каждой запятой, и ДОЛЖЕН быть один пробел после каждой запятой.

Аргументы замыкания со значениями по умолчанию должны идти в конце списка аргументов.

Объявление замыкания выглядит следующим образом. Обратите внимание на размещение круглых скобок, запятых, пробелов и фигурных скобок:

```php
$closureWithArgs = function ($arg1, $arg2) {
    // тело функции
};

$closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) {
    // тело функции
};
```

Список аргументов и список переменных МОЖЕТ быть разделен на несколько строк, где каждая последующая строка с одним отступом. 
При этом первый элемент в списке ДОЛЖЕН быть на следующей строке, и ДОЛЖЕН быть только один аргумент или переменная на строку.

Когда конечный список (или аргументов или переменных) разделен на несколько строк, закрывающая круглая скобка и открывающая 
фигурная скобка ДОЛЖНЫ быть установлены вместе на их собственную строку с одним пробелом между ними.

Ниже приведены примеры замыканий с и без списка аргументов и списка переменных разбитого на несколько строк

```php
$longArgs_noVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) {
   // тело функции
};

$noArgs_longVars = function () use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // тело функции
};

$longArgs_longVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // тело функции
};

$longArgs_shortVars = function (
    $longArgument,
    $longerArgument,
    $muchLongerArgument
) use ($var1) {
   // тело функции
};

$shortArgs_longVars = function ($arg) use (
    $longVar1,
    $longerVar2,
    $muchLongerVar3
) {
   // тело функции
};
```

Обратите внимание, что правила форматирования применяются также когда замыкание используется прямо как аргумент при вызове метода или функции.

```php
$foo->bar(
    $arg1,
    function ($arg2) use ($var1) {
        // тело функции
    },
    $arg3
);
```

## Symfony Code Standards

### Структура

Один пробел после каждой запятой

пробелы перед и после операторов (==, &&, ...)

Запятая после каждого элемента массива, даже последнего

Пустая строка перед `return`, за исключением случая, когда `return` -- единственное выражение в группе выражений (например, в блоке `if`)
 
Используйте фигурные скобки вокруг тела управляющих конструкций в независимости от количества выражений в теле (например, даже 
когда в if -- одно выражение)

Определяйте только один класс в каждом файле. Это не относится к классам-хелперам, которые не инстанцируются

В классах определяйте свойства перед методами

Сначала определяйте `public` методы, потом `protected` и затем `private`. Единственное исключение из данных правил -- конструктор класса
 и `setUp` и `tearDown` методы классов юнит-тестов, которые всегда идут первыми для улучшения читаемости
 
Всегда используйте скобки при инстанциировании классов, вне зависимости от количества аргументов конструктора (всегда `new SomeClass()` а не `new SomeClass`)

Сообщений исключений форматируйте с помощью `sprintf`
 
```php
throw new Exception\InvalidArgumentException(sprintf(
    '%s expects a string argument; received "%s"',
    __METHOD__,
    (is_object($param) ? get_class($param) : gettype($param))
));
```

### Наименования

Используйте `camelCase`, а не `under_scores` для переменных, функций, имён методов и аргументов

Используйте `under_score` для имён опций и параметров

Используйте пространства имён для всех классов

Используйте префикс `Abstract` для всех абстрактных классов

Используйте постфикс `Interface` для всех интерфейсов

Используйте постфикс `Trait` для всех трейтов

Используйте постфикс `Exception` для всех исключений

используйте `alphanumeric` символы и символ подчёркивания для имён файлов

Для автодополнения и тайпхинтинга используйте слова `bool` (а не `boolean`, `Boolean`), `int` (а не `integer`), `float` (а не `double` или `real`)


### Документирование

добавляйте PHPDoc блоки для всех классов, методов и функций

Опускайте @return тег, если функция не возвращает ничего

@package и @subpackage не испольуются


### Пример

```php
/*
 * This file is part of the Symfony package.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Acme;

/**
 * Coding standards demonstration.
 */
class FooBar
{
    const SOME_CONST = 42;

    private $fooBar;

    /**
     * @param string $dummy Some argument description
     */
    public function __construct($dummy)
    {
        $this->fooBar = $this->transformText($dummy);
    }

    /**
     * @param string $dummy Some argument description
     * @param array  $options
     *
     * @return string|null Transformed input
     *
     * @throws \RuntimeException
     */
    private function transformText($dummy, array $options = array())
    {
        $mergedOptions = array_merge(
            array(
                'some_default' => 'values',
                'another_default' => 'more values',
            ),
            $options
        );

        if (true === $dummy) {
            return;
        }

        if ('string' === $dummy) {
            if ('values' === $mergedOptions['some_default']) {
                return substr($dummy, 0, 5);
            }

            return ucwords($dummy);
        }

        throw new \RuntimeException(sprintf('Unrecognized dummy option "%s"', $dummy));
    }
}
```
